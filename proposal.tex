%!TEX root=main.tex
\section{Cautious Adaptation Approach}

Given a component that does not satisfy the global requirements of a system, although it is necessary to use the component. We call this component {\em defiant} if it can still be modified by adapting the system wrapping around it. In general, when a self-adaptive system can have multiple components that need to be adapted to its global requirement, however, none of them alone can achieve this demand. In this section, we lay out a step-wise approach to address this problem (see an overview in Figure~\ref{fig:process}).

\subsection{Overview}

Initially, we aim to model the core functional requirements for the self-adaptive system, and the local requirements for each component using scenarios. They formalise both exceptional and normal conditions of the system, which have been widely used for modelling {\it what-if} situations. 

The verification of the satisfaction arguments of global requirements and local requirements provides designer a formal basis to tell whether or not defiant behaviour exists in the components, and whether or not addressing the defiant behaviours (i.e., an off-the-shelf component cannot satisfy the global requirements out of the box). 

The process to address a defiant component is divised into two phases, the design-time phase uses scenarios to model the system for formally verifying the defiant behaviour problems and the self-adaptive solutions; the run-time phase deploys the self-adaptive solutions to incorporate sensors and actuators to form a MAPE-K loop.  

It assumes the use of off-the-shelf software components, with predefined requirements and specifications. 
Assuming that high-level message sequence charts (hMSC) and basic message sequence charts are used to model the defiant behaviour in the system.  Given the similarities between exceptional and what-if conditions, the approach uses existing formal method techniques, like feedback-driven implied scenario resolutions~\cite{uchitel:2013}, to verify scenarios represented as message sequence charts (MSC) translated into labelled transition systems (LTS), with respect to safety and liveness properties. 
%\textbf{Note: we need a justification here!}
The reason for converting scenarios into LTS formally is to facilitate the correctness checks of the model before and after the adaptation.

The scenarios representing the system (with the off-the-shelf components) are transformed into LTS behaviour models, and requirements are transformed into properties. Then the design-time phase to address a defiant behaviour includes four steps, as follows. 
\begin{itemize}
\item {\bf Monitoring contextual variables.} In this step, contextual variables for analysing the global requirements are elicited such as battery levels, distance to destination, drone is on water or not, and whether or not the wind is favorable, etc.  These variables may not be available or used for analysing the local requirements of the component. Nonetheless, from a bigger picture usually they are critical to tell the satisfaction of the global requirements. 
\item {\bf Analysing exceptional conditions.} 
The situations when the satisfaction of local requirements denies the satisfaction of global requirements are analysed to identify the exceptional conditions. The what-if situations marks exceptional conditions on an extension of the scenario models, which will also be transformed into safety properties in LTS.  E.g., battery level is lower than 10\%, distance to destination is smaller than 2km, the drone is on the water, and the wind is favourable to cover the remaining distance with fewer power. The combination of these conditions would trigger a sitatuion that it is in fact possible to satisfy the global requirements by the drone, only if some of its existing safety assumption is updated. In the opposite case, the failed checks are used to identify how to deal with exceptional conditions. %From the counter examples provided by the model checker (i.e., sequences of actions that lead to failures), software designers can inspect which of the actions can be avoided by negating the conditions that trigger these action in the behavioural model. These triggered conditions are combined to form exceptional conditions. The negation of an exceptional condition is considered as a normal condition.
\item {\bf Planning adaptation actions.} In this step, the exceptions can be addressed by executing changes in the component. If the component can be reconfigured, its model is checked against required properties. Using the existing functionalities such as maneuveuring, while disabling certain functionaties such as safe landing, it is possible to switch to a different solution through adaptation. Such adapations are modelled as advices such as before / around of existing functionalities/actions in the adapted component.  
\item {\bf Simulating circumventing behaviours.} Under exceptional conditions the alternative adaptation actions need to be called, however, the existing component is not designed to be adaptable. In this step we uses aspect-oriented mechanisms to weave the changes into the system behaviours and pass the modified behavioural model back to the verification step. Note that this step is still performed at the design time, therefore we cannot call it ``execution", but it is corresponding to the execution step of the MAPE self-adaptive system at the runtime.
\end{itemize}

A model checker is applied to verify whether the off-the-shelf component can also satisfy  global requirements of the system-of-system, for which not necessarily it was designed. In the case when the component satisfies the requirements, it can be used as-is in the system-of-system. However, when the component cannot be changed (i.e., the case of a defiant component), a wrapper is specified in order to weave exceptional conditions into the component specification in LTS, and it is verified by the LTSA model checker against the properties.  The adaptation is considered {\it cautious} only when {\bf all} the properties (local and global) are satisfied by the component within the system-of-system context. The verification step is considered successful, that is, the defiant behaviours can be addressed by design-time simulation and verifications. 

However, there are still two additional steps to be added before it can be deployed to the runtime.

\begin{itemize}
\item {\bf Sensing contexts.} The contextual variables identified at the design-time must be observable directly or indirectly using dedicated sensors. If they are in place, appropriate interpretation of the readings need to be added to relate the observed behaviours with the monitored properties.
\item {\bf Actuating controls.} Similarly, the controls in the system need to be added to wrapper around the defiant components when necessary. With such wrapping, the input to the original component may need to be filtered so that, without internal changes to the component, the composed wrapper would satisfy the global requirements the original component is not aware of. 
\item {\bf Aspect execution engine.} Connecting the components and the wrapper together is the role of aspect execution engine, which not only ensure that the design-time model are faithfully executed at the runtime, but also potential conflicts between the wrappers of multiple defiant components are handled properly. 
\end{itemize}

Therefore, the cautious adaptation approach involves designing a wrapper aspect, which is defined by a specification of the pointcuts and advices on the scenarios, and transforming them into LTS specifications by extending the previous work of scenario to LTS translation. After that, the LTS specifications of both the global context and the wrapped component will be used to check, formally, whether or not the adapted system satisfy the safety properties of both the global requirements in the exceptional conditions and the local requirements in the normal conditions.

%First, when an off-the-shelf component is used in an emergent global system, scenarios are specified with respect to the global and local requirements.By transforming these scenarios into LTS behaviour models, along with their requirements transformed into properties, we use model checker to tell whether the off-the-shelf component can satisfy the global requirements, which it was not designed for. Upon failure to satisfy the requirements, the designer can ask it to change its behaviour. However, resisting to the change request, the designer has to identify the component as a defiant component, and treat it cautiously.

\begin{figure*}[h]\centering
% \includegraphics[width=0.9\columnwidth]{figures/activity.eps}
 \includegraphics[width=0.8\textwidth]{figures/workflow}
 \caption{Overview of the cautious adaptation approach in a workflow diagram}
 \label{fig:process}
 \vspace*{-0.5cm}
\end{figure*}

%Our approach to cautious adaptation of a defiant component is explained below.

%illustrates the main constructs and relationships between the defiant component and the wrapper framework. The cautious adaptation weaving is responsible of 1) exposing the exceptional conditions of defiant component; 2) identifying the failure of the defiant component under the exceptional conditions; and 3) modifying the functionality of the defiant component to satisfy both exceptional and normal conditions. All these responsibilities can be defined as properties in the behaviour models that can be checked formally. 

%\begin{figure}[ht]
%\includegraphics[width=\columnwidth]{figures/overview.eps}
%\caption{Overview of Cautious Adaptation Framework}\label{fig:overview}
%\vspace*{-1cm}
%\end{figure}

%\subsection{Discussion about Self-Adaptation}

%Existing self-adaptive systems rely on a full monitoring-analysis-planning-execution (MAPE) feedback loop to continuously monitor the environment and switch to alternative solutions when the requirements are not satisfied. However, we observe that it is not always necessary to monitor the entire process. Given the prior knowledge of the environment, to reduce the monitoring and adaptation overhead, it is possible to monitor only part of the processes while switch to part of the solutions when the adaptation is required.  In this way, cautious adaption can be seen as a means towards more efficient self-adaptation.
% TODO. Can we evaluate the efficiency of self-adaptation by measuring the efficiency?


\subsection{Formalisation}

The general problem being tackled can be formalised using the semantics of Problem Frames~\cite{DBLP:books/daglib/0022946}, as follows. At the design time of a defiant component ($c$), given its world context ($W_c$), its specification ($S_c$) must satisfy its requirements ($R_c$), i.e., $W_c, S_c \models R_c$. 

%For instance, consider drone component $c$ with two requirements $R_c = R_1 \wedge R_2$, where $R_1$ is ``to fly from location $A$ to location $B$ when the battery level is above a threshold $\theta = 10\%$'' ($W_1$), and $R_2$ is ``to land safely when the battery level drops below $\theta$'' ($W_2 = \neg W_1$).

Suppose that component $c$ is being used as part of a system-of-systems ($s$). Based on the analysis of exception scenarios concerning a specific context of the system ($W_s$), which satisfies the condition $W_s \implies W_c$, component $c$ cannot satisfy global requirements of $s$. In other words, $W_s, S_s \not \models R_s$, where $S_s$ contains $S_c$. 

%In order to illustrate, consider the drone application scenario with an exceptional condition defined as $W_s = W_2 \wedge W_3 \wedge W_4$ where the battery level is below $\theta$ ($W_2$), but the battery level is sufficient to fly to location $B$ because of the wind condition ($W_3$), and it is flying above water by design of $S_s$ ($W_4$). According to the designed specification of the component $S_c$, the drone will land because of $W_2$, regardless of $W_3$, and the drone will land in the water because of $W_4$. The only feasible solution is to avoid safe landing in $W_s$, because if one rescues the landed drone from the water, it will be too late to replace it with another means of transportation even if the payload will not be damaged. Therefore, the problem is that it is not possible to change the specification of $S_c$. 

To verify that the wrapper executes its purpose, we formalise three conditions to be checked as follows:
\[
\begin{array}{ll}
W_s, S_s \not \models R_s & (\mbox{defiant identification})\\
W_s, S_s |_{c\rightarrow w(c)} \models R_s & (\mbox{defiant removal}) \\
W_c \setminus W_s, S_{w(c)} \models R_c & (\mbox{safety assurance})
\end{array}
\]
\begin{itemize}
\item Defiant identification checks that the component is defiant because its configurations do not satisfy global requirements.

\item Defiant removal checks that after wrapping up the defiant component with new behaviour, the global requirement can be restored in exceptional conditions.

\item Safety assurance checks that after wrapping up the defiant component with new behaviour, the local requirements are still satisfied in normal conditions. 
\end{itemize}

\subsection{Scenario Extensions on MSC}
To support the method, we extend the message sequence chart (MSC) specification with a decision point  to represent an \textit{interception point} in which exceptional conditions can be added around the defiant component. 

Several exceptional conditions can be intercepting in the same decision point, indicating other possible behaviours according to alternative contexts. If there is no exceptional scenario plugged in an interception point, the expected default behaviour is performed.
\begin{figure*}[h]\centering
%    \includegraphics[width=\columnwidth]{figures/new_drone_msc.png}
 \includegraphics[width=0.8\textwidth]{figures/1-hMSC-Drone.png}
    \caption{Extended hMSCs for the drone scenario. Each box defines a basic message sequence, while a transition between the boxes is marked by a guard condition (e.g., $b>10 \wedge d>0$ and an action, e.g., $\{ b'=b-1\}$. The black dot in the middle is added to separate the normal condition $b\leq 10$ into three exceptional conditions, namely, $d\leq 2 \wedge onWater=1 \wedge strongWind=1$, $d>2 \wedge onWater=1$, and otherwise. Each exceptional condition introduces a different basic message sequence box. 
E.g., Keep Flying and Move Aside are two handlers of these two exceptional conditions. After exceptions are handled, the control may not return to the original target sequence. E.g., Keep Flying will return control to Landed, circumventing the original Safe Landing sequence. }
    \label{fig:hmsc}
    \vspace*{-0.25cm}
\end{figure*}

Figure~\ref{fig:hmsc} shows part of high-level message sequence charts (hMSC) specification for the payload organ delivery scenario discussed in Section 1. Each box in the hMSC corresponds to a basic message sequence chart (bMSC), like UML sequence diagrams, exchanging messages between different entities, whilst the bMSC are put together through control flows (branches and loops). 
%Figure~\ref{fig:drone_bmsc} depicts the referred bMSCs for part of the drone payload delivery example.   
%\begin{figure}
%    \includegraphics[width=\columnwidth]{figures/new_drone_bmsc.png}
%    \caption{bMSCs for the drone delivery scenario}
%    \label{fig:drone_bmsc}
%    \vspace*{-0.5cm}
%\end{figure}
% To move into implementation section

We have developed LoTuS, an integrated development environment that supports the modeling of the extended hMSC, for what-if scenario analysis.
Figure~\ref{fig:lotus} displays a screenshot when a tool is being used to create the model in Figure~\ref{fig:hmsc}.
\begin{figure*}
 \includegraphics[width=0.8\textwidth]{figures/2-LoTuS.png}
    \caption{LoTus: an IDE for modeling the extended MSCs. The project explore navigation view on the left shows the specification of individual bMSCs. }
    \label{fig:lotus}
    \vspace*{-0.25cm}
\end{figure*}

\subsection{(Candidate) Research Questions}

\begin{itemize}
\item {\bf RQ1.} Can defiant behaviour be identified from the modeling of the scenarios of the component and its environment (including the  other components in the global system)? 

\item {\bf RQ2.} Is it possible to resolve definant behaviours by creating a wrapper to satisfy the global requirements using existing defiant components?

\item {\bf RQ3.} If possible, how many changes are required to adapt the behaviour of a defiant component? Would such adapation benefit from having aspect-oriented wrappers?

\item {\bf RQ4.} Can the simulation of the self-adaptive aspect-oriented wrappers be implemented using aspect-oriented programming?

\item {\bf RQ5.} Can multiple aspect-oriented wrappers be applied to a more complex scenario correctly, and efficiently? 
\end{itemize}

\subsection{Evaluation}

\begin{itemize}
\item {\bf RQ1.} {\em Can defiant behaviour be identified from the scenarios of the component and its environment (including the  other components in the global system)? }

At the design time, we need to define the verifiable FSP properties that can be checked by the LTSA model checker.

At the runtime, we need to define the  monitoring conditions of the involved context variables based on the sensor readings, so that when the monitoring conditions are
triggering the defiant behaviours (traced to the execution of scenarios) are identified. We need to define necessary and sufficient conditions. 

\item {\bf RQ2.} {\em Is it possible to resolve definant behaviours by creating a wrapper to satisfy the global requirements using existing defiant components?}

At the design time, we need to model check the property that the composed scenarios do not violating the global requirements.

At the runtime, we need to ensure that the analysis can be done efficiently. Is it possible to use BDD to reduce the runtime requirements satisfaction down to a decision tree model that is efficient to compute? 

\item {\bf RQ3.}{\em  If possible, how many changes are required to adapt the behaviour of a defiant component? Would such adapation benefit from having aspect-oriented wrappers?}

At the design time, we need to measure the number of changes introduced to the behaviour model of a defiant component, with or without aspect-oriented wrappers.

At the runtime, we need to justify the extra indirection due to the aspect invocation. 

\item {\bf RQ4.} {\em Can the simulation of the self-adaptive aspect-oriented wrappers be implemented using aspect-oriented programming?}

At the design time, we need to measure the number of changes introduced to the behaviour model of a defiant component, with or without aspect-oriented wrappers.

At the runtime, we need to justify the extra indirection due to the aspect invocation does not causing too much overhead.

\item {\bf RQ5.} {\em Can multiple aspect-oriented wrappers be applied to a more complex scenario correctly, and efficiently? }

At the design time, we need to check the adverse condition of ``feature interaction'' does not matter to the composition of aspect wrappers.

At the runtime, we need to justify enforce the reliability / resilience of execution of the aspect compositions. 
\end{itemize}
\begin{figure*}
 \includegraphics[width=\textwidth]{figures/3-parameterized-LTS.png}
    \caption{Parameterised LTS illustrates the behaviours when the contextual variables are parameters bound to user specified constants. }
    \label{fig:pLTS}
    \vspace*{-0.25cm}
\end{figure*}

\begin{figure*}
 \includegraphics[width=0.8\textwidth]{figures/4-Land-final-LTS.png}
    \caption{LTS of Landing: the partial behaviour of landing bMSC, where the unnamed transitions are the transitions between different bMSCs. Though an $\epsilon$-reduction, these transitions will be removed.}
    \label{fig:landing}
    \vspace*{-0.25cm}
\end{figure*}

\begin{figure*}
 \includegraphics[width=0.8\textwidth]{figures/5-KeepFlying-final-LTS.png}
    \caption{LTS of Keep Flying in LoTuS: user can specify the values of contextual variables interactively, which resulting in a different LTS when the ``Run'' button is clicked. Note that we are not executing the behaviour model, only simulating it at the design time.}
    \label{fig:keepflying}
    \vspace*{-0.25cm}
\end{figure*}

\begin{figure*}
 \includegraphics[width=0.8\textwidth]{figures/6-MoveAside-final-LTS.png}
    \caption{LTS of Moving Aside behaviour modelled in LoTuS. It is the results of a different context where the values of the contextual variables are different from Keep Flying.}
    \label{fig:movingaside}
    \vspace*{-0.25cm}
\end{figure*}

==========================

In Figure~\ref{fig:drone_msc}, the predefined scenarios are represented by a full rectangle and are part of the normal specification of a drone, while the exceptions are represented by dashed rectangles. As shown in Figure~\ref{fig:drone_msc}, through a controller the pilot can control the drone to take off, and can manoeuvre the drone when the battery is above a certain threshold $\theta = 10\%$, while it has not reached the destination. When the pilot sends a landing command to the drone, this is acknowledged when the drone lands in the ground.  During a flight, a drone periodically checks the status of its internal devices such as battery level and distance from the destination, represented by \textit{b} and \textit{d}, respectively, in the guard conditions over the transitions. In the example, if the battery level is above the expected threshold and the drone is not yet in its destination, the drone keeps flying. If the drone reaches its destination, it performs a landing action. If the battery is below the expected threshold, the drone performs a safe landing in accordance to its predefined specification. 

The exceptional conditions added in the interception point state that if the distance to the expected destination is less than 2km, the drone is flying over the river (condition \textit{on\_water==true}), and the wind is strong (condition \textit{wind==strong}), then the pilot can keep the drone flying even in a low-level battery situation and then land, thus being able to complete its overall goal (delivering the medical payload) successfully. Nonetheless, if the battery is low, the drone is above water, but the drone is more than 2km away or the wind is not strong,
% Paolo: Fig 2 needs update
% "[d > 2]" => "[d > 2 || wind!=strong]"
then the action is to move the drone aside in order to land it on the ground. 

% Figure~\ref{fig:overview} shows an overview of the relationship between the defiant component and the wrapper technique. The cautious adaptation approach is responsible to: (i) expose exceptional conditions of defiant components; (ii) identify failure of  defiant components under the exceptional conditions; and (iii) modify the functionality of defiant components to satisfy both exceptional and normal conditions. All these responsibilities can be defined as properties in behaviour models that can be checked formally. 

\subsection{The Wrapper Aspect}
The introduction of a {\it wrapper} $w(c)$ changes the defiant behaviour of the component $c$, i.e. $W_s, S_{w(c)} \not \models R_c$, retaining the essential satisfaction of global requirements when $c$ is substituted with $w(c)$:  $W_s, S'_s \models R_s$ where $S'_s = S_s |_{c \rightarrow w(c)}$. Furthermore, the adaptation is {\it cautious} because other than the exceptional condition $W_s$, the wrapped component should still behave like the original designed component, i.e., $(W_c \setminus W_s), S_{w(c)} \models R_c$. 

%\subsubsection{A Wrapper by Aspect-Orientation}
Based on aspect-oriented programming (AOP)~\cite{Kiczales:2001}, we introduce wrappers that can achieve the above requirements. The exceptional conditions identified in the scenarios provide an indication where changes in the system should occur ({\it joint points}). Once the join points are identified, we represent them as regular expressions as {\it point-cuts}, so that a replacement of the behaviour after the join points can be done through aspect {\it advices}. Aspect advices are exceptionally handled, which can invoke existing functionalities of original components, but can also introduce additional functions and conditions that do not exist in the original components.

%Since a component at design time is unaware of its future exceptional usage, it will not be able to expose its full implementation to the system integrator. Fortunately, {\it aspect-oriented} framework can intercept the control flow of the behavioural specification~\cite{Xu07}. 

%For example, to identify the join points, i.e., where  modifications are allowed to change. Methodologically, the exceptional conditions we obtain from the exceptional scenarios provide us a clue where such join points can be.

%Once the join points are identified, we can use regular expressions to express them as {\it point-cuts} so that a replacement of the behaviour after the join points can be done through aspect {\it advices}. Aspect advices in this situation are exceptional handling which can still invoke existing functionality of the original components, but can also introduce additional functions and conditions that do not exist in the original component. But the weaving of the aspect-oriented wrapper must be performed with caution. 

In the situation in which there are more than one wrapper for the same exceptional condition, to avoid interference~\cite{Katz:2008:IAI:1394496.1394500}, we define a precedence order among wrappers. For example, a safety wrapper is regarded with a high-level of importance and should be applied afterwards, to override applied unsafe wrappers. 

